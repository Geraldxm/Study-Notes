- 最大子串和；
- 无向图最长路径
- 表达式求值；
- 给一棵树求最长的路径。
## 卡特兰数
- n 个元素进栈序列为：1，2，3，4，...，n，则有多少种合法出栈序列。
- [「算法入门笔记」卡特兰数 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/97619085)
- n 对括号，则有多少种 “括号匹配” 的括号序列
- `n + 1` 个叶子节点能够构成多少种形状不同的（国际）满二叉树
	- ![[Pasted image 20240529141120.png]]
- 电影票一张 50 coin，且售票厅没有 coin。m 个人各自持有 50 coin，n 个人各自持有 100 coin。则有多少种排队方式，可以让每个人都买到电影票。
	- ![[Pasted image 20240529141314.png]]
## 计算排列组合数


## KMP
```C++
// next[i]=k表示以ch[i]为后缀的，最长有k个和前缀相等

#include <iostream>
#include <string>
#include <vector>

using namespace std;

// 计算next数组
void getNext(const string &pattern, vector<int> &next) {
    int len = pattern.size();
    next.resize(len, 0);
    int j = 0;

    for (int i = 1; i < len; ++i) {
        while (j > 0 && pattern[i] != pattern[j]) {
            j = next[j - 1];
        }
        if (pattern[i] == pattern[j]) {
            j++;
        }
        next[i] = j;
    }
}

// KMP算法
int KMP(const string &text, const string &pattern) {
    int n = text.size();
    int m = pattern.size();
    vector<int> next;
    getNext(pattern, next);
    int j = 0;

    for (int i = 0; i < n; ++i) {
        while (j > 0 && text[i] != pattern[j]) {
            j = next[j - 1];
        }
        if (text[i] == pattern[j]) {
            j++;
        }
        if (j == m) {
            return i - m + 1; // 返回第一个匹配的位置
        }
    }

    return -1; // 没有匹配
}

int main() {
    string text = "ABC ABCDAB ABCDABCDABDE";
    string pattern = "ABCDABD";

    int pos = KMP(text, pattern);

    if (pos != -1) {
        cout << "Found pattern at position: " << pos << endl;
    } else {
        cout << "Pattern not found" << endl;
    }

    return 0;
}
```